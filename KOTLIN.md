# Kotlin

> Kotlin is a multiplatform, statically typed, general-purpose programming language. Kotlin took inspiration from many programming languages, including (but not limited to) Java, Scala, C# and Groovy. One of the main ideas behind Kotlin is being pragmatic, i.e., being a programming language useful for day-to-day development, which helps the users get the job done via its features and its tools. Reference: https://kotlinlang.org/spec/kotlin-spec.html

Learning materials:
- [Learning materials overview](https://kotlinlang.org/docs/learning-materials-overview.html)
- [Kotlin Tutorial For Beginners 2023](https://www.youtube.com/watch?v=TEXaoSC_8lQ)
- [Kt. Academy / Marcin Moska≈Ça](https://kt.academy/article)
  - https://kt.academy/Kotlin_Cheat_Sheet.pdf
  - https://github.com/MarcinMoskala/advanced-kotlin-workshop-tasks

---

In IntelliJ IDEA, you can view the **Kotlin bytecode** generated by the compiler and even **decompile it to Java** to understand how Kotlin features (like coroutines, suspend functions, etc.) are translated under the hood.

## Kotlin releases

[Top features of Kotlin releases | KOTLIN_RELEASE.md](KOTLIN_RELEASE.md)

## Compiler

![img](images/kotlin-compiler.png)

[Reference1](https://kt.academy/article/ak-compiler-plugin)

[Reference2](https://github.com/ahinchman1/Kotlin-Compiler-Crash-Course)

There are two frontends, k1 and k2. K2, otherwise known as FIR frontend.

In compilers, the frontend translates a computer programming source code into an intermediate representation, and the backend works with the intermediate representation to produce code in a computer output language.

## Error hierarchy

In Kotlin, there are only unchecked exceptions that are thrown during the runtime execution of the program. All exception classes descend from the class Throwable.

Reference: https://www.baeldung.com/kotlin/exception-handling

## Data types

![img](images/kotlin-datatypes.png)

[Reference](https://medium.com/@m.sandovalcalvo/kotlin-type-system-unveiling-the-mystery-50613f0db893)

In Kotlin, all classes implicitly inherit from the Any type (similar to Object in Java). The Any class provides three basic operations that can be overridden in any Kotlin class:
- equals(other: Any?): Boolean	Determines whether two objects are equal (default: checks for referential equality using ===).
- hashCode(): Int	Returns a hash code for the object, used in hash-based collections (default: generates a unique value based on object identity).
- toString(): String	Returns a string representation of the object (default: prints the class name and memory reference).

Default Implementations of These Functions in Any:
```kotlin
open class Any {
    open operator fun equals(other: Any?): Boolean = this === other
    open fun hashCode(): Int = System.identityHashCode(this)
    open fun toString(): String = this::class.java.name + "@" + Integer.toHexString(hashCode())
}
```

---

Kotlin does not have primitives at the language level, but Kotlin/JVM optimizes primitive types under the hood.

Kotlin does not expose primitives like Java (int, double, etc.), but it automatically maps them to Java primitives when possible.

- `Int?` (Kotlin) == `Integer` (Java)
- `Int` (Kotlin) == `int` (Java)

## Visibility modifiers

Visibility modifiers are used to control the access level of classes, functions, properties, and other members. They determine where a member can be accessed from, providing control over the encapsulation of code and reducing the chances of misuse.

| Modifier  | Description                                                                                                                                                                       | Access Level                                                           |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------|
| public    | The default visibility for classes, functions, and properties if no modifier is specified. It means the member is accessible from anywhere.                                       | Accessible everywhere (inside the same module and from other modules). |
| internal  | Makes the member visible inside the same module but not outside. This is useful for library code where you want to restrict access to certain parts of your code within a module. | Accessible within the same module.                                     |
| protected | Used in classes and subclasses. It makes the member visible to the class and its subclasses (even if they are in a different package).                                            | Accessible in the class and its subclasses.                            |
| private   | Restricts access to the member within the containing class or file.                                                                                                               | Accessible only within the class or file where it is declared.         |

## Collection literals

In Kotlin, collection literals refer to a concise and direct way to create collections (lists, sets, and maps) using built-in factory functions. Kotlin does not yet support true collection literals like array literals ([1, 2, 3]) in JavaScript or Python, but it provides easy-to-use functions for collection creation.

```kotlin
listOf(1,2,3,4) // List<Int>
mutableListOf(1,2,3,4) // MutableList<Int>

setOf("A", "B", "C") // Set<String>
mutableSetOf("A", "B", "C") // MutableSet<String>

arrayOf('a', 'b', 'c') // Array<Char>

mapOf(1 to "A", 2 to "B") // Map<Int, String>
mutableMapOf(1 to "A", 2 to "B") 

// MutableMap<Int, String>
sequenceOf(4,3,2,1) // Sequence<Int>
1 to "A" // Pair<Int, String>
List(4) { it * 2 } // List<Int>
generateSequence(4) { it + 2 } // Sequence<Int>
```

| Feature              | List                                                | Sequence                                                          |
|----------------------|-----------------------------------------------------|-------------------------------------------------------------------|
| Evaluation           | Eager (computed immediately)                        | Lazy (computed when accessed)                                     |
| Memory Usage         | Higher (stores all elements)                        | Lower (processes elements one by one)                             |
| Indexed Access       | Yes (`list[index]`)                                 | No                                                                |
| Intermediate Results | Stored in new lists                                 | Computed only when needed                                         |
| Performance          | Better for small datasets                           | Better for large datasets with multiple transformations           |
| Best Use Case        | When you need fast random access or a small dataset | When working with large datasets and chaining multiple operations |

```kotlin
val list = (1..1_000_000).toList()
val sequence = (1..1_000_000).asSequence()

// List (creates multiple intermediate lists)
val listResult = list.map { it * 2 }.filter { it % 3 == 0 }.take(10)

// Sequence (efficient, no intermediate lists)
val sequenceResult = sequence.map { it * 2 }.filter { it % 3 == 0 }.take(10).toList()

println(listResult)      // Same output
println(sequenceResult)  // Same output, but more efficient
```

## Functions

A function is a block of reusable code designed to perform a specific task.

```kotlin
val lambda: () -> Unit = {
// code
}
```

The Kotlin compiler determines how to represent the lambda depending on how it is used and the context in which it's declared. In most cases, the lambda will be compiled into a function object that implements a relevant functional interface, like Function0<Unit> (or another appropriate functional interface depending on the lambda signature). The class representing this lambda can either be an anonymous inner class or a named class, depending on the situation.

**Anonymous Inner Class (JVM Anonymous Class)**

When you define the lambda directly within a function or expression (as in the example), the Kotlin compiler will usually generate a JVM anonymous class that implements the appropriate interface (e.g., Function0<Unit> for a lambda with no parameters and no return value). This anonymous class has an invoke() method that contains the body of the lambda.

The lambda is represented by an anonymous inner class that implements the Function0<Unit> interface.

This approach is typical when:
- The lambda is used locally within a function or a small scope.
- No specific class name is needed, and the lambda is a one-time or transient object.

```java
Function0<Unit> lambda = new Function0<Unit>() {
  @Override
  public Unit invoke() {
    System.out.println("Hello, World!");
    return Unit.INSTANCE;
  }
};

```

**Named Class in a Separate File**

In some situations, particularly when the lambda is stored in a property or used in more complex scenarios (e.g., when passed across class boundaries or referenced multiple times), Kotlin might generate a named class in a separate file to hold the lambda's implementation.

This approach is used when:
- The lambda is declared in a class or object and needs to be reused multiple times.
- The Kotlin compiler chooses to generate a named class to ensure better code organization or when required by certain Kotlin features (e.g., lambda capturing or reusing).

```java
// Additional class in separate file
public class Test$lambda implements Function0 < Unit > {
    public Unit invoke() {
        // code
    }
};
```

```java
Function0 lambda = new Test$lambda();
```

Which One is Used When?
- Anonymous Class is typically used for short-lived, inline lambdas that are used only once or twice.
- Named Class might be used in scenarios where the lambda needs to be passed around, reused, or encapsulated for longer-lived objects or more complex behavior.

### Function types

- () -> Unit        - takes no arguments and returns nothing (Unit).
- (Int, Int) - >Int - takes two arguments of type Int and returns Int.
- (()->Unit) -> Int - takes another function and returns Int.
- (Int)->() -> Unit - takes argument of type Int and returns function.

### Function literals

In Kotlin, function literals are expressions that represent functions without a name. These are often used for short-lived, inline functions that don't need to be defined separately. Function literals can be passed around as values, assigned to variables, or used directly in higher-order functions.

```kotlin
val add: (Int, Int) -> Int = { i, j -> i + j }
// Simple lambda expression
val printAndDouble: (Int) -> Int = {
 println(it) 
 // When single parameter, we can reference it using `it`
 it * 2 // In lambda, last expression is returned
}
// Anonymous function alternative
val printAndDoubleFun: (Int) -> Int = fun(i: Int): Int {
 println(i) // Single argument canÔøΩt be referenced by `it`
 return i * 2 // Needs return like any function
}
```

### Inline functions

In Kotlin, inline functions are functions that the compiler replaces with their body at the call site. This means the function is not actually called at runtime‚Äîinstead, its code is inserted directly where it's used.

Why use inline functions?
- Performance Boost
  - Avoids function call overhead (especially for small functions).
  - Useful in performance-critical scenarios.
- Higher-Order Functions Optimization
  - When passing a lambda, inline functions avoid creating extra objects and function calls.
  - Reduces memory allocations and improves efficiency.
- Allows reified Type Parameters
  - Normally, generic type parameters are erased at runtime (type erasure).
  - `inline` allows reified types, meaning we can use type information at runtime.

When Should You Use Inline Functions?
- ‚úÖ Good Use Cases:
  - Small, frequently called functions (to avoid function call overhead).
  - Higher-order functions (functions taking lambdas as parameters) to avoid object creation.
  - Generic functions needing reified type parameters.

- ‚ùå Avoid Inline When:
  - The function is large (it will increase code size).
  - It‚Äôs only called once (no real benefit from inlining).
  - The function isn‚Äôt performance-critical.
  - The function is recursive (Kotlin doesn‚Äôt allow inlining recursive functions).

**Example 1: Higher-Order Function Optimization**

```kotlin
fun nonInlineHigherOrder(action: () -> Unit) {
    println("Before action")
    action()
    println("After action")
}

fun main() {
    nonInlineHigherOrder { println("Executing Action!") } // Creates a lambda object
}
```
- When using regular functions with lambda parameters, Kotlin creates a lambda object, which takes extra memory.

```kotlin
inline fun inlineHigherOrder(action: () -> Unit) {
    println("Before action")
    action()  // No lambda object is created!
    println("After action")
}

fun main() {
    inlineHigherOrder { println("Executing Action!") }
}
```
- With inline, no lambda object is created:

**Example 2: Using reified with Inline Functions**

Normally, you cannot access the generic type at runtime:
```kotlin
fun <T> printType(obj: T) {
    println(T::class) // ‚ùå ERROR: Cannot use 'T' as reified type parameter
}
```

```kotlin
inline fun <reified T> printType(obj: T) {
    println(T::class)  // ‚úÖ Works because T is reified
}

fun main() {
    printType("Hello") // Prints: class kotlin.String
}
```
- With inline and reified, we can access the type at runtime:

---

Final Thoughts
- Use inline for small, performance-sensitive functions.
- Use inline for higher-order functions to avoid extra lambda object allocations.
- Use reified with inline for generic type safety at runtime.
- Avoid inline for large functions as it increases the final code size.

### Scope functions

The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions. There are five of them: let, run, with, apply, and also.

https://kotlinlang.org/docs/scope-functions.html

## equals

By default, in Kotlin, the equals() method is inherited from the Any class, which is the root of the Kotlin class hierarchy (similar to Object in Java). The default implementation of equals() checks for referential equality, meaning it checks whether two references point to the exact same object in memory. This is equivalent to the === operator in Kotlin.

```kotlin
open class Any {
    open fun equals(other: Any?): Boolean {
        return this === other
    }
}
```

```kotlin
class Person(val name: String)

fun main() {
    val person1 = Person("Alice")
    val person2 = Person("Alice")
    val person3 = person1

    println(person1 == person2)  // Output: false (because they are different instances)
    println(person1 === person3) // Output: true (because they refer to the same instance)
}
```

When you declare a data class in Kotlin, the equals() method is automatically overridden by the compiler to perform structural equality comparison, not just referential equality. The compiler generates an equals() method that compares all the properties declared in the primary constructor of the data class.

```kotlin
data class Person(val name: String, val age: Int)

fun main() {
    val person1 = Person("Alice", 30)
    val person2 = Person("Alice", 30)
    
    println(person1 == person2)  // Output: true (because it checks for structural equality)
}
```

## Inferred type

Inferred type means that the compiler automatically determines the type of a variable, function return value, or expression without explicitly specifying it. Kotlin's type inference makes code concise while ensuring type safety.

```kotlin
val name = "Kotlin"  // Compiler infers type as String
val age = 25         // Compiler infers type as Int
val isActive = true  // Compiler infers type as Boolean
```

## require vs check vs assert

| Function  | Purpose                        | Exception Type                            | Use Case                       |
|-----------|--------------------------------|-------------------------------------------|--------------------------------|
| `require` | Checks function arguments      | `IllegalArgumentException`                | Validating function parameters |
| `check`   | Checks object state/invariants | `IllegalStateException`                   | Ensuring internal consistency  |
| `assert`  | Debugging-only checks          | `AssertionError` (disabled in production) | Sanity checks in development   |

```kotlin
fun pop(num: Int = 1): List<T> {
 require(num <= size) {
 "Cannot remove more elements than current size" 
}
 check(isOpen) { "Cannot pop from closed stack" }
 val ret = collection.take(num)
 collection = collection.drop(num)
 assert(ret.size == num)
 return ret
}
```

## Smart casting

Smart casting is a feature in Kotlin that allows the compiler to automatically cast a variable to a more specific type without explicit casting, provided that the compiler can guarantee its type at runtime.

> How it works?
> If a variable is checked using is (or !is) and the compiler can ensure that it hasn't changed between the check and usage, it automatically casts the variable to the checked type.

```kotlin
fun printLength(obj: Any) {
    if (obj is String) { // Type check
        println(obj.length) // Smart cast: obj is automatically treated as String
    } else {
        println("Not a string")
    }
}
```

```kotlin
fun process(value: Any) {
    when (value) {
        is Int -> println(value + 1) // Smart cast to Int
        is String -> println(value.uppercase()) // Smart cast to String
        else -> println("Unknown type")
    }
}
```

Smart casting does not work if the variable:
- Is mutable (var) because it may change after the type check.
- Has a custom getter because the compiler cannot track the value.

## Receiver function

A `receiver function` (or a function with receiver) in Kotlin is a function that allows you to call it as if it were a method of the receiver object. This means that within the function, you can directly access the properties and methods of the receiver object using `this`.

Receiver functions were introduced to make the code more readable and expressive, and to allow the creation of Domain-Specific Languages (DSLs) in Kotlin. They enable you to extend classes with new functionality without modifying their source code, providing a cleaner and more modular way to add methods to existing classes.

**Extension Function**:

```kotlin
fun String.sayHello(): String {
    return "Hello, $this!"
}

fun main() {
    val name = "Alice"
    println(name.sayHello())  // Output: Hello, Alice!
}
```

**Lambda with Receiver**:

```kotlin
fun buildString(builder: StringBuilder.() -> Unit): String {
    val sb = StringBuilder()
    sb.builder()
    return sb.toString()
}

fun main() {
    val result = buildString {
        append("Hello, ")
        append("world!")
    }
    println(result)  // Output: Hello, world!
}
```

```kotlin
fun sum(arr: Array<Int>): Int = arr.reduce { acc, element -> acc + element }
```

Receiver (reader in this case) is also passed as an argument to the lambda:
```kotlin
fun countCharactersInFile(path: String): Int {
   BufferedReader(FileReader(path)).use { reader ->
   return reader.lineSequence().sumBy { it.length }
  }
}
```

### this vs it

In Kotlin, a receiver refers to the object on which a function or property is invoked. Receivers are mainly used in extension functions and lambdas with receivers, enabling a concise and flexible way to operate on objects.

| Feature                  | Extension Function Receiver                                       | Lambda with Receiver                                                 |
|--------------------------|-------------------------------------------------------------------|----------------------------------------------------------------------|
| Definition               | Used in extension functions to refer to the object being extended | Used in lambdas where `this` refers to the object inside the lambda  |
| Keyword used             | `this`                                                            | `this` (implicit)                                                    |
| Example usage            | `fun String.addExclamation() = this + "!"`                        | `"Hello".run { println(this) }`                                      |
| Alternative reference    | Cannot use `it`                                                   | Can use `it` in some cases (e.g., `let` uses `it` instead of `this`) |
| Common functions used in | Extension functions (`fun ClassName.functionName()`)              | `apply`, `run`, `with`, `also`                                       |
| Purpose                  | Extending functionality of existing classes                       | Modifying or working with an object inside a lambda                  |

## Delegates

Delegates allow you to delegate certain functionality to another object instead of implementing it yourself. This helps in code reusability, better separation of concerns, and reducing boilerplate code. Kotlin provides two main types of delegation:
- Property Delegation
  - Property delegation allows you to delegate the getter and setter behavior of a property to another object using the by keyword.
  - Built-in Property Delegates
    - Kotlin provides some built-in property delegates, such as:
      - lazy ‚Äì for initializing a property only when it's accessed for the first time. 
      - observable ‚Äì for tracking changes to a property. 
      - vetoable ‚Äì for validating before assigning a new value.

```kotlin
class Example {
    val name: String by lazy { 
        println("Initializing name...")
        "Kotlin"
    }
}

fun main() {
    val example = Example()
    println(example.name) // First access triggers initialization
    println(example.name) // Subsequent accesses use the stored value
}
```

```kotlin
import kotlin.properties.Delegates

class User {
    var name: String by Delegates.observable("Unknown") { _, old, new ->
        println("Name changed from $old to $new")
    }
}

fun main() {
    val user = User()
    user.name = "Alice"
    user.name = "Bob"
}
```

```kotlin
var age: Int by Delegates.vetoable(18) { _, old, new ->
    new >= 18 // Only allows setting if new value is 18 or older
}

fun main() {
    println(age)  // 18
    age = 21      // Allowed
    println(age)  // 21
    age = 16      // Not allowed, remains 21
    println(age)  // 21
}
```

- Class Delegation (Interface Delegation)
  - Instead of implementing an interface manually, you can delegate the implementation to another object using the by keyword.

```kotlin
interface Printer {
    fun printMessage()
}

class SimplePrinter : Printer {
    override fun printMessage() = println("Printing from SimplePrinter")
}

class AdvancedPrinter(printer: Printer) : Printer by printer

fun main() {
    val simplePrinter = SimplePrinter()
    val advancedPrinter = AdvancedPrinter(simplePrinter)
    
    advancedPrinter.printMessage() // Delegates call to SimplePrinter
}
```

## Variance modifiers

Variance modifiers in Kotlin (in, out) define how generic types can be used in relation to subtyping. They help manage covariance and contravariance, ensuring type safety when working with generics.

- Covariance (out)
  - Allows a generic type to be a subtype of another generic type with a supertype.
  - Declares that a type parameter can only be produced (returned) and not consumed (accepted as input).
  - Used when a generic class only produces values (e.g., List<T>).
  - Helps with subtyping (List<String> is a subtype of List<Any>).
- Contravariance (in)
  - Allows a generic type to be a supertype of another generic type with a subtype.
  - Declares that a type parameter can only be consumed (accepted as input) and not produced (returned).
  - Used when a generic class only consumes values (e.g., Comparator<T>).
  - Helps with subtyping (Comparator<Any> is a subtype of Comparator<String>).
- Invariance (Default Behavior)
  - By default, Kotlin generics are invariant, meaning no subtyping is allowed.
  - A generic type `Container<T>` is not a subtype of `Container<S>`, even if S is a supertype of T.

| Modifier    | Type Parameter Usage                                      | Variance Type     | Example Usage                                                                            |
|-------------|-----------------------------------------------------------|-------------------|------------------------------------------------------------------------------------------|
| `out`       | Can only be **produced** (returned), not consumed (input) | **Covariant**     | `List<out T>` (e.g., `List<String>` can be used as `List<Any>`)                          |
| `in`        | Can only be **consumed** (input), not produced (returned) | **Contravariant** | `MutableList<in String>` (e.g., `MutableList<Any>` can be used as `MutableList<String>`) |
| No modifier | Can be both produced and consumed                         | **Invariant**     | `Container<T>` (e.g., `Container<String>` is **not** `Container<Any>`)                   |


- Use out when you only return (produce) values.
- Use in when you only accept (consume) values.
- Use invariance (default) when a type is used both for input and output.

## Coroutines

A coroutine is an instance of a suspendable computation. Conceptually, it's similar to a thread: it runs a block of code concurrently with the rest of the program.
However, unlike threads, coroutines are lightweight and not bound to any specific thread. They can suspend execution in one thread and resume in another.

Why do we need to learn Kotlin Coroutines? On JVM, we already have well-established libraries like RxJava or Reactor. 
Moreover, Java itself has its support for multithreading. While Java‚Äôs multithreading and existing libraries like RxJava and Reactor offer solid solutions for concurrency and reactive programming, Kotlin coroutines provide an easier-to-use, more efficient, and **more readable alternative**.

Coroutines always execute in some context that is a set of various elements.
The context is a holder of data that is needed for the coroutine. The main elements are:
- Job - represents a cancellable unit of work. It models a coroutine‚Äôs lifecycle, which ends with its completion (either normally or due to cancellation).
- Dispatcher ‚Äì Determines the thread(s) on which the coroutine will execute. Kotlin provides several implementations:
  - `Dispatchers.Default` uses a shared thread pool optimized for CPU-intensive work. The pool size typically matches the number of available CPU cores.
  - `Dispatchers.IO` is optimized for offloading blocking I/O operations like file or network access.
  - `Dispatchers.Main` is present only on platforms that have main threads, such as Android and iOS.
  - `Dispatchers.Unconfined` doesn‚Äôt change the thread and launches the coroutine in the caller thread. The important thing here is that after suspension, it resumes the coroutine in the thread that was determined by the suspending function.
    - While Unconfined can be useful for specific scenarios, it is rarely used in production environments because it can lead to unpredictable thread behavior

To launch a coroutine, we need to use a **coroutine builder** like `launch` or `async`.
These builder functions are actually extensions of the CoroutineScope interface:
- GlobalScope (async,launch)
    - The lifecycle of this scope is tied to the lifecycle of the whole application. This means that the scope will stop running either after all of its coroutines have been completed or when the application is stopped.
      - Coroutines in GlobalScope do not keep the process alive (similar to daemon threads).
    - It‚Äôs worth mentioning that coroutines launched using GlobalScope do not keep the process alive. They behave similarly to daemon threads. So, even when the application stops, some active coroutines will still be running. This can easily create resource or memory leaks.
    - `async` is designed to perform something in the background and return a result, while `launch` is designed to perform an action in the background without necessarily returning a result (Just Fire It and Forget).
      - `launch`: Starts a coroutine without returning a result.
      - `async`: Starts a coroutine that returns a result via a Deferred.
- runBlocking
    - It runs a coroutine blocking the current thread until all child coroutines complete.
    - Intended for bridging between blocking and non-blocking code (e.g., in main() or unit tests).
    - Avoid in production code‚Äîit negates the benefits of coroutines by blocking threads.

`CoroutineStart` is an enum in Kotlin that defines how a coroutine is started. It allows you to control the behavior of the coroutine when it is launched, and there are four main options for how a coroutine can begin its execution:
- DEFAULT
  - The coroutine is started immediately when it's launched.
- LAZY
  - The coroutine is not started immediately. Instead, it will be started manually later by invoking the start() method on the job or by using join().
- ATOMIC
  - This option starts the coroutine immediately (like DEFAULT), but it will ensure that the coroutine starts without being canceled in between the start and the first suspension point. 
  - It's useful when you want to guarantee that the coroutine cannot be canceled right after it begins execution, until it hits its first suspension point.
- UNDISPATCHED
  - The coroutine starts immediately, but it will run on the thread that initiates it until it hits a suspension point. After the first suspension, it will resume on the dispatcher specified in the coroutine context.
  - This can be useful when you want the coroutine to start executing immediately but prefer to switch to another dispatcher as soon as it suspends.

These options are used when creating coroutines with functions like launch, async, etc. You pass the CoroutineStart option as part of the start parameter to control when and how the coroutine is started.

```kotlin
val job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {
    println("Atomic coroutine starts immediately and cannot be canceled before the first suspension point")
    delay(1000L)
    println("Coroutine resumed after delay")
}
```

Kotlin Example: GlobalScope Not Keeping Process Alive
```kotlin
import kotlinx.coroutines.*

fun main() {
    GlobalScope.launch {
        delay(2000)
        println("Finished work")
    }

    Thread.sleep(500) // main thread ends quickly
    println("Main ends")
}
```

```text
Main ends
```

```kotlin
fun main() {
    val job = GlobalScope.launch {
        delay(2000)
        println("Finished work")
    }

    runBlocking {
        job.join() // wait for coroutine to finish
    }
}
```

References:
- https://www.baeldung.com/kotlin/threads-coroutines
- https://kt.academy/article/cc-coroutine-context
- https://www.baeldung.com/kotlin/coroutines-scope-vs-context
- https://kt.academy/article/cc-use-scope-vs-suspend
- https://medium.com/@erik.antonyan1994/understanding-structured-concurrency-in-kotlin-coroutines-5693f941a898

```kotlin
import kotlinx.coroutines.*

suspend fun main() = runBlocking {
    println("Parent coroutine starts")

    coroutineScope {
        launch {
            delay(1000)
            println("Child coroutine 1 completes")
        }

        launch {
            delay(500)
            println("Child coroutine 2 completes")
        }
    }

    println("Parent coroutine ends")
}
```
- `runBlocking` starts the main coroutine (often used in main()).
- `coroutineScope { ... }` creates a structured block where:
  - Two child coroutines are launched.
  - The parent coroutine (main) waits until both child coroutines finish.
- If any child coroutine fails or gets cancelled, the whole scope is cancelled‚Äîensuring consistent and safe cleanup.

```kotlin
coroutineScope {
    launch {
        delay(500)
        println("Child 1 done")
    }

    launch {
        delay(300)
        throw RuntimeException("Oops!")
    }
}
```
In this case:
- The exception will cancel both coroutines.
- coroutineScope propagates failure up, and runBlocking catches it if not handled.

Here's an example that shows how supervisorScope allows one child coroutine to fail without cancelling the others, which contrasts with coroutineScope:
```kotlin
import kotlinx.coroutines.*

suspend fun main() = runBlocking {
    println("Parent starts")

    supervisorScope {
        launch {
            try {
                delay(300)
                throw RuntimeException("Child 1 failed!")
            } catch (e: Exception) {
                println("Caught exception in Child 1: ${e.message}")
            }
        }

        launch {
            delay(500)
            println("Child 2 completed successfully")
        }
    }

    println("Parent ends")
}
```

```text
Parent starts
Caught exception in Child 1: Child 1 failed!
Child 2 completed successfully
Parent ends
```

| Scope Type        | Behavior on Child Failure                                                  |
|-------------------|----------------------------------------------------------------------------|
| `coroutineScope`  | Cancels all child coroutines if **any** child fails                        |
| `supervisorScope` | Allows other child coroutines to continue if one fails (isolated failures) |

### Suspension points

```kotlin
suspend fun main(): Unit = coroutineScope {
    val job = Job()  // Create a new Job
    launch(job) {    // Launch a coroutine with the job
        repeat(1_000) { i ->
            Thread.sleep(200)  // This is a blocking call
            // Complex operations or file I/O can be here
            println("Printing $i")  // Printing
        }
    }
    delay(1100)  // Wait for 1.1 seconds
    job.cancelAndJoin()  // Cancel the job and wait for it to finish
    println("Cancelled successfully")  // Print that cancellation is complete
    delay(1000)  // Wait a little after cancellation
}
```

Suspension points are places in a coroutine where the coroutine can pause execution, release the thread, and then later resume from where it left off.

Examples of suspension points include:
- `delay()`: This suspends the coroutine and releases the underlying thread, so other work can be done.
- `yield()`: Suspends the coroutine voluntarily and allows other coroutines to execute.
- `withTimeout()`, `withContext()`, and other coroutine builders.

However, blocking operations like Thread.sleep() are not suspension points. They block the entire thread and don't allow the coroutine to suspend properly. This causes problems when you try to cancel the coroutine.

The original code will execute the entire loop until all 1,000 iterations are completed, because the coroutine is blocked by Thread.sleep(200) and cannot respond to cancellation until after the sleep finishes.

The cancellation is checked at each iteration only if the coroutine is suspended (i.e., at suspension points). The whole loop will execute without checking for cancellation in the middle because of Thread.sleep(), which doesn't allow the coroutine to suspend and check for cancellation. Without the initial `delay`, the coroutine wouldn't start because it would check at the beginning if it's cancelled.

Solution: Use delay() Instead of Thread.sleep()

### Coroutines vs Suspend Functions

| Feature     | Coroutine (`launch {}` / `async {}`)               | Suspend Function (`suspend fun`)                              |
|-------------|----------------------------------------------------|---------------------------------------------------------------|
| Purpose     | Represents a full concurrent task or flow          | Represents a single suspending step                           |
| Usage       | Used to start a coroutine block                    | Can be called only from another coroutine or suspend function |
| Lifecycle   | Manages its own lifecycle (`Job`)                  | Part of a coroutine; doesn't manage its own scope             |
| Return Type | `launch` returns `Job`, `async` returns `Deferred` | Returns any type like a regular function                      |
| Example     | `scope.launch { fetchData() }`                     | `suspend fun fetchData() { ... }`                             |

In Kotlin coroutines, `async` and `await` are used to handle asynchronous tasks. The async function starts a coroutine and returns a Deferred object, which represents a future result. You can then call await() on the Deferred object to get the result of the computation, suspending the calling coroutine until the result is available.
- async {}: Starts an asynchronous coroutine that performs a task in the background. It immediately returns a Deferred object, which can be used to later get the result of the asynchronous computation.
- await(): Suspends the coroutine and waits for the result of the Deferred object. It doesn't block the thread; it allows other coroutines to run while waiting.

### Structured Concurrency

`Structured concurrency` treats groups of related tasks running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability.

Structured concurrency is a programming model that ensures coroutines are launched in a hierarchical way, where:
- Parent coroutines wait for their children to complete before finishing.
- Cancellation of a parent propagates to its children.

This model brings predictability and safety, much like how functions behave in synchronous code.

[Reference](https://ericniebler.com/2020/11/08/structured-concurrency/)

### Loom vs Coroutines

`Virtual threads` are a new type of thread introduced in `Project Loom`, which was a preview in Java 19. Unlike traditional platform threads, which are directly tied to the operating system's thread management, virtual threads are managed by the Java runtime itself.

- Loom can improve the performance applications: it can run multiple virtual threads and it costs less to have blocked virtual threads than to have a regular threads blocked. 
  - Kotlin coroutines are intrusive because we cannot call suspend functions in normal function, which is not the case of Loom.
- Structured concurrency is much more easier with Kotlin coroutines than Loom.
- Interoperability between Kotlin coroutines and reactive programming are more simpler as we can just use flows than the one between loom and reactive programming.

[Reference](https://stackoverflow.com/questions/77053797/java-virtual-threads-vs-kotlin-coroutines)

> A virtual thread still runs code on an OS thread. However, when code running in a virtual thread calls a blocking I/O operation, the Java runtime suspends the virtual thread until it can be resumed. The OS thread associated with the suspended virtual thread is now free to perform operations for other virtual threads.

- A virtual thread runs on an OS thread. 
- When a virtual thread blocks (e.g., on I/O), the associated OS thread is freed up to run other virtual threads.
  - When a virtual thread blocks on I/O, the underlying OS thread isn't idly waiting for the I/O operation to complete. Instead, the Java runtime can suspend the virtual thread, freeing up the OS thread to do other work. The actual I/O operation, which might involve reading from or writing to a disk, network, or some other resource, continues in the background.
- Virtual threads are not permanently bound to a single OS thread.

https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html#GUID-2BCFC2DD-7D84-4B0C-9222-97F9C7C6C521

Virtual Thread (Blocking on I/O):
- Blocked on I/O: When a virtual thread performs a blocking operation (like reading from a file or waiting for network data), it gets suspended. The OS thread that was running the virtual thread is now free to perform other tasks or run other virtual threads.
- No active waiting: The virtual thread doesn't actively do anything while it's waiting for I/O to complete. It's essentially "paused" until the I/O operation finishes, at which point it gets resumed by the Java runtime.
- Java runtime manages suspension/resumption: The runtime handles this for you, so you don't have to deal with non-blocking APIs or callbacks. This allows many threads to be managed concurrently with minimal overhead.

Non-blocking I/O:
- Thread doesn't block: In non-blocking I/O, the thread initiates the I/O operation and then immediately returns to do other tasks. The thread doesn't wait for the I/O operation to finish.
- Callback or polling: The thread may get notified when the I/O operation completes (e.g., using a callback mechanism or by polling the I/O status). The thread can then process the result of the I/O operation once it's ready.
- Explicit management: You typically need to explicitly manage when to check for readiness or handle completion, which is more complex but gives you fine-grained control over when and how to process I/O results.

```java
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.nio.charset.*;
import java.util.concurrent.*;

public class NonBlockingIOExample {
    public static void main(String[] args) throws Exception {
        // Path to the file to read
        Path path = Paths.get("example.txt");

        // Create a new ExecutorService to manage threads
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // Open an AsynchronousFileChannel for reading
        AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ, executor);

        // Allocate a ByteBuffer to hold the file data
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        // Asynchronously read from the file (non-blocking)
        fileChannel.read(buffer, 0, buffer, new CompletionHandler<Integer, ByteBuffer>() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                // This method is called when the I/O operation completes
                System.out.println("Read " + result + " bytes.");

                // Flip the buffer to read the data
                attachment.flip();
                Charset charset = Charset.forName("UTF-8");
                String content = charset.decode(attachment).toString();
                System.out.println("File content: " + content);
                
                // Clean up
                try {
                    fileChannel.close();
                    executor.shutdown();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                // This method is called if the I/O operation fails
                exc.printStackTrace();
            }
        });

        // The main thread can continue to perform other tasks here
        System.out.println("Reading file asynchronously...");

        // Keep the main thread alive until the file reading is done
        Thread.sleep(5000);
    }
}
```

#### Similarities

| Feature                   | Java Virtual Threads                                           | Kotlin Coroutines                                  |
|---------------------------|----------------------------------------------------------------|----------------------------------------------------|
| Lightweight               | Virtual threads are also lightweight and cheap to create       | Coroutines are lightweight and cheap to create     |
| Scheduler-managed         | Scheduler maps virtual threads to platform threads             | Dispatcher decides on what thread to run           |
| Suspension/Blocking model | Virtual threads block, but the JVM handles it efficiently      | Coroutines suspend (non-blocking)                  |
| Concurrency abstraction   | Same ‚Äî allows parallel tasks without managing threads directly | Provide high-level concurrency without raw threads |

#### Key Differences

| Feature                        | Java Virtual Threads                                                             | Kotlin Coroutines                                           |
|--------------------------------|----------------------------------------------------------------------------------|-------------------------------------------------------------|
| Programming Model              | Based on blocking code that‚Äôs managed by the JVM (from JDK 21 with Project Loom) | Based on suspend functions and structured concurrency       |
| Syntax                         | Uses regular blocking code                                                       | Requires `suspend` functions                                |
| Thread Model                   | One virtual thread maps to a platform thread temporarily                         | Multiple coroutines can share threads                       |
| Scheduling                     | Uses ForkJoinPool or custom Executors                                            | Uses CoroutineDispatchers                                   |
| Concurrency Abstraction        | Based on threads, behaves like regular code                                      | Structured concurrency with `launch`, `async`               |
| Scheduling                     | Handled by JVM scheduler                                                         | Uses `CoroutineDispatcher`                                  |
| Integration with Blocking APIs | Seamless (no need for new APIs)                                                  | Needs careful handling (e.g. `withContext(Dispatchers.IO)`) |
| Structured Concurrency         | üö´ No native support (requires discipline)                                       | ‚úÖ Built-in with `coroutineScope`, `supervisorScope`         |
| Use Case                       | Best for making blocking code scalable                                           | Best for writing scalable async workflows                   |

### Channels

Channels in Kotlin Coroutines provide a way to transfer values between coroutines safely and asynchronously.
They work like concurrent queues but are designed specifically for coroutines,
supporting suspending send and receive operations.

Why Use Channels?
- Avoid Shared Mutable State ‚Üí Channels allow safe communication between coroutines.
- Producer-Consumer Pattern ‚Üí Efficient data processing between sender and receiver.
- Backpressure Support ‚Üí The sender suspends when the channel is full, preventing memory issues.

Types of Channels
- Rendezvous (default)
  - No buffer: The sender suspends until the receiver is ready. It's a one-to-one communication where data is sent only when both parties are ready to receive and send.
- Buffered
  - Limited-size buffer: The sender suspends only when the buffer is full. It can store a set number of elements before blocking the sender.
- Conflated (Replaced by StateFlow)
  - Retains only the latest value: Older values are discarded when a new one arrives. Use StateFlow in place of ConflatedChannel for a similar effect. It ensures that only the most recent value is emitted to consumers.
- Unlimited
  - Infinite buffer: The sender never suspends, as there‚Äôs an unbounded amount of space in the buffer to store values. However, this can lead to memory issues if not used carefully.
- Ticker
  - Emits items at a fixed time interval: The channel generates items at a regular interval, useful for timed events or polling.

When to Use Channels?
- When you need to pass data between coroutines safely.
- For producer-consumer scenarios (e.g., background tasks).
- When you need backpressure handling.

‚ùå Don't use channels for simple data sharing ‚Üí Prefer Flow or StateFlow.

üí° Summary
- Channels allow coroutines to communicate safely.
- They support suspending send and receive operations.
- Different types: Rendezvous, Buffered, Conflated, Unlimited, Ticker.
- Use produce {} for structured producer-consumer patterns.
- Prefer Flow if you only need simple reactive streams.

---

| Feature               | üî• Hot Streams                           | ‚ùÑÔ∏è Cold Streams                      |
|-----------------------|------------------------------------------|--------------------------------------|
| Start Behavior        | Starts emitting immediately              | Starts emitting only when collected  |
| Shared Emissions      | Emissions are shared among collectors    | Each collector gets a fresh sequence |
| Collectors Late Join  | Miss previously emitted values           | Always start from the beginning      |
| Examples              | `SharedFlow`, `StateFlow`, `LiveData`    | `Flow`, `sequence`, `flow {}`        |
| Use Case              | UI State, Events, Real-time updates      | Data transformations, API fetching   |
| Backpressure Handling | Needs manual buffer config               | Built-in backpressure support        |
| Replay Option         | Can replay with buffer (e.g., StateFlow) | No built-in replay                   |


#### Flow vs Channel

- Channel is used for communication between coroutines, while Flow is used for representing a stream of asynchronous data.
- Channel is hot, pushing data when available, while Flow is cold, producing data only when collected.
- Channel is more low-level, whereas Flow is a more declarative abstraction that supports transformations.

### Flow vs StateFlow

- State Management: StateFlow always holds a latest value which can be accessed synchronously, while Flow does not store values and only emits items when collected.
- Hot vs Cold: StateFlow is a hot flow that continuously emits values to collectors, while Flow is cold and starts emitting values only when it is collected.
- Updates: The value in StateFlow can be updated synchronously, while in regular Flow, data is emitted asynchronously by the producer.

In summary, StateFlow is a state-holder that allows both synchronous access to the current state and asynchronous observation of state changes. It is ideal for scenarios where you need to manage and observe a continuously updated state, such as UI-related state in an application.

### Actors

In Kotlin, actors are a powerful concept for managing concurrency and state in a safe and structured way. An actor is a coroutine that serves as a single-threaded worker, handling incoming messages in a sequential manner, which allows you to safely manage mutable state without requiring complex synchronization mechanisms like locks.

An actor is typically used to:
- Encapsulate mutable state.
- Ensure that only one coroutine can access and modify the state at a time.
- Process messages asynchronously in a non-blocking manner.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.actor

// Define messages that the actor will process
sealed class CounterMsg
class Increment(val value: Int) : CounterMsg()
class GetCount(val replyTo: CompletableDeferred<Int>) : CounterMsg()

// Actor that will process messages and maintain state
fun CoroutineScope.counterActor() = actor<CounterMsg> {
    var count = 0
    for (msg in channel) {
        when (msg) {
            is Increment -> count += msg.value
            is GetCount -> msg.replyTo.complete(count)
        }
    }
}

fun main() = runBlocking {
    // Launch the actor
    val counter = counterActor()

    // Send messages to the actor
    counter.send(Increment(1))   // Increment the counter by 1
    counter.send(Increment(5))   // Increment the counter by 5

    // Request the current count from the actor
    val response = CompletableDeferred<Int>()
    counter.send(GetCount(response))

    // Wait for the response and print it
    println("Current count: ${response.await()}")  // Output: Current count: 6

    // Close the actor after use
    counter.close()
}
```

## How to achieve immutability?

- Use val Instead of var (Immutable Variables)
- Use Immutable Data Classes (data class)
- Use Immutable Collections (List, Set, Map)
  - listOf(), setOf(), mapOf() ‚Üí Immutable
  - mutableListOf(), mutableSetOf(), mutableMapOf() ‚Üí Mutable
- Use object for Singleton Immutability
- Use @JvmInline for Inline Value Classes
- Use sealed class for Immutable State Handling (State Management)
  - Cannot be extended outside the file ‚Üí Safer modeling!

## Void vs Unit vs Nothing

- Void: Represents the absence of a return value but is specific to Java.
- Unit: The Unit represents the absence of a meaningful return value. It is similar to void in Java but is a type in Kotlin. Such a function is usually performing some kind of side effect.
- Nothing: Nothing represents a type that never successfully returns. It indicates that the function either throws an exception or never completes.
    - Use Case: Used to signify functions that throw exceptions or are infinite loops. It is a type of function that never returns normally.
- Reference: <https://stackoverflow.com/questions/55953052/kotlin-void-vs-unit-vs-nothing>

```kotlin
fun fail(message: String): Nothing {
    throw IllegalArgumentException(message)
}
```

## const vs const val

- const val is used to declare compile-time constants. These constants are inlined at compile time and are fully resolved during the build process.
    - Can only be used for properties of primitive types (Int, Double, Boolean, etc.) and String that are defined at the top level or inside an object or companion object.
- In Kotlin, const is used ONLY in conjunction with val. It signifies that the value is a compile-time constant.
- Use val when the value is not known at compile time (e.g., computed dynamically).

---

Even though both are immutable, the key difference is:
- const val is inlined at compile time ‚Üí Faster performance, no memory overhead
- val is a runtime constant ‚Üí Stored as a variable in memory

Let's take this Kotlin code:
```kotlin
const val CONST_MESSAGE = "Hello, Kotlin!"
val VAL_MESSAGE = "Hello, Kotlin!"

fun printMessage() {
    println(CONST_MESSAGE)
    println(VAL_MESSAGE)
}
```

```java
System.out.println("Hello, Kotlin!");
```

The compiler replaces CONST_MESSAGE directly with "Hello, Kotlin!" ‚Üí No memory allocation.

## @JvmStatic vs companion object

- A companion object is a special object within a class that allows you to define methods and properties that are associated with the class itself, rather than with instances of the class.
    - You use a companion object to hold static-like members, similar to static fields and methods in Java. Kotlin classes don't have static members, but you can use a companion object to achieve a similar effect.
- The @JvmStatic annotation is used to mark members of a companion object (or top-level functions) to be exposed as static methods in Java. This helps with interoperability between Kotlin and Java.
- When you annotate a member of a companion object with @JvmStatic, it will be accessible as a static member in the generated Java bytecode. This is useful when you want to call Kotlin code from Java and need static-like behavior.
- Static Access from Java:
    - Without @JvmStatic, members of a companion object are accessed through the companion object itself in Java (e.g., MyClass.Companion.someMethod()).
    - With @JvmStatic, the members are accessed directly from the class (e.g., MyClass.someMethod()).
- Ref: <https://stackoverflow.com/questions/48780003/why-and-when-to-use-jvmstatic-with-companion-objects>

## Defensive and offensive programming

Defensive and offensive programming are two approaches to writing code that manage potential issues, errors, and exceptions in different ways. Both aim to ensure the stability of the program, but they take distinct approaches to handling uncertainties.

### Defensive Programming

Defensive programming involves writing code in a way that anticipates potential issues and safeguards against them. The goal is to protect the program from possible misuse or unexpected behavior, ensuring that it behaves safely even in cases of invalid input, wrong configurations, or unexpected states.

Characteristics of Defensive Programming:
- Input Validation: Always validate inputs to ensure they meet expected conditions before using them.
- Null Safety: Use safe calls and null checks to avoid NullPointerException.
- Error Handling: Anticipate errors and handle them gracefully (e.g., using try-catch blocks).
- Preconditions: Ensure that preconditions are met before executing a block of code.
- Guard Clauses: Early returns to handle invalid cases quickly.

```kotlin
fun safeDivide(a: Int, b: Int): Int? {
    // Defensive check for division by zero
    if (b == 0) {
        println("Cannot divide by zero")
        return null
    }
    return a / b
}

fun processData(data: String?) {
    // Defensive null check
    if (data == null || data.isEmpty()) {
        println("Invalid data provided")
        return
    }
    println("Data processed: $data")
}
```

### Offensive Programming

Offensive programming, on the other hand, involves writing code under the assumption that things will go wrong, but you focus on exposing errors as early as possible. It often involves letting the code fail fast, focusing on catching issues at the point of failure rather than trying to prevent them.

Characteristics of Offensive Programming:
- Fail Fast: Let the program fail at the earliest point possible if something unexpected happens.
- Assertions: Use assertions to check invariants and conditions that should always be true.
- Assume Correct Inputs: Trust that inputs will be correct but catch errors if they are not.
- Throw Exceptions: If an issue arises, throw an exception immediately rather than trying to handle the problem internally.

```kotlin
fun divide(a: Int, b: Int): Int {
    // Offensively throwing an exception if division by zero occurs
    require(b != 0) { "Division by zero is not allowed" }
    return a / b
}

fun processData(data: String) {
    // Assume the data should always be non-null and non-empty
    check(data.isNotEmpty()) { "Data cannot be empty" }
    println("Data processed: $data")
}
```

### Key Differences

| Aspect                        | **Defensive Programming**                         | **Offensive Programming**                                    |
|-------------------------------|---------------------------------------------------|--------------------------------------------------------------|
| **Goal**                      | Prevent failures by anticipating possible errors  | Let the program fail fast if something goes wrong            |
| **Approach to Inputs**        | Validate inputs before using them                 | Assume inputs are correct, but catch errors when they occur  |
| **Error Handling**            | Handle errors gracefully to prevent crashes       | Throw exceptions or fail immediately on incorrect conditions |
| **Failing Strategy**          | Try to avoid errors and mitigate risks            | Fail fast and expose errors immediately                      |
| **Example Constructs**        | `try-catch`, null checks, validation              | `require`, `check`, `assert`                                 |
| **Readability & Performance** | Can make code more verbose with additional checks | Makes code more concise but may expose bugs sooner           |

## Why premature optimization is bad?

Premature optimization refers to optimizing code before confirming that the optimization is necessary or beneficial. While optimizing code can improve performance, doing it too early can introduce unnecessary complexity, reduce maintainability, and even degrade performance in unexpected ways.

- It Wastes Development Time
  - Developers may spend time optimizing parts of the code that don‚Äôt significantly impact overall performance. 
  - Time spent on premature optimizations could be better used for writing clean, correct, and maintainable code.
- It Increases Code Complexity
   - Optimized code often becomes harder to read, debug, and maintain. 
   - Complex optimizations introduce more bugs and edge cases.
   - Issue:
     - In many cases, simple joinToString() works just as well.
     - The StringBuilder version adds extra complexity unless performance profiling shows a bottleneck.

  ```kotlin
  fun buildStringOptimized(parts: List<String>): String {
      val builder = StringBuilder()
      parts.forEach { builder.append(it) }
      return builder.toString()
  }
  ```

- It Can Make Future Changes Difficult
   - Overly optimized code is harder to modify and debug. 
   - Future changes might require rewriting optimized code entirely.
   - Issue:
     - While technically faster, it's not readable for most developers.
     - The compiler already optimizes n * 8 efficiently.
     - Future developers might misinterpret the intent.
  
  ```kotlin
  fun multiplyByEight(n: Int): Int {
      return n shl 3 // Bitwise shift left (n * 8)
  }
  ```

-  The Compiler and JVM Already Optimize Well
  - Modern compilers (Kotlin, Java, JVM JIT, etc.) perform many optimizations automatically. 
  - Manual micro-optimizations are often redundant.
  -  Issue:
    - The JVM already inlines small functions where beneficial. 
    - Marking everything inline can increase bytecode size instead of improving speed.

  ```kotlin
  inline fun square(n: Int) = n * n
  ```

- Optimization Without Profiling is Guesswork 
  - Without profiling tools, developers don't know which part of the code is slow. 
  - Optimization should focus on actual bottlenecks proven by benchmarks.
